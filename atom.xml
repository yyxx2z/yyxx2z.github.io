<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuantumZ</title>
  
  <subtitle>Blog site of yyxx2z</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yyxx2z.github.io/"/>
  <updated>2019-03-25T10:04:30.900Z</updated>
  <id>http://yyxx2z.github.io/</id>
  
  <author>
    <name>yyxx2z</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数式编程_0x1</title>
    <link href="http://yyxx2z.github.io/2019/01/16/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-0x1/"/>
    <id>http://yyxx2z.github.io/2019/01/16/函数式编程-0x1/</id>
    <published>2019-01-16T14:30:11.000Z</published>
    <updated>2019-03-25T10:04:30.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><ul><li>编程范式</li><li>函数式编程的特征</li><li>函数式编程解决的问题</li><li>柯里化</li><li>组合</li><li>尾调用及尾调用优化</li><li>Hindley-Minler 类型签名</li><li>范畴论与函数式编程</li></ul><a id="more"></a><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B" target="_blank" rel="noopener">编程范式（Programming Paradigm）</a>即典型的编程风格，而目前主要使用的编程范式有：</p><ul><li>面向对象编程</li><li>命令式编程 (Imperative Programming)</li><li>声明式编程 (Declarative Programming)</li><li>函数式编程 (Functional Programming)</li></ul><p>这里简单介绍下其中的三种编程范式：</p><h4 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h4><p>命令式编程关注于<strong>计算机执行的步骤</strong>，即一步一步地告诉机器怎么去处理一件事情达到预期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如如何从一个喜欢的圈子获得朋友</span></span><br><span class="line"><span class="comment">// 导入爱好</span></span><br><span class="line"><span class="keyword">import</span> &#123; hobits, isLike &#125; <span class="keyword">from</span> <span class="string">'mine'</span></span><br><span class="line"><span class="keyword">import</span> &#123; groups &#125; <span class="keyword">from</span> <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> friends = []</span><br><span class="line"><span class="comment">// 随机选择一个爱好</span></span><br><span class="line"><span class="keyword">const</span> hobit = hobits[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * hobits.length)] </span><br><span class="line"><span class="comment">// 随机选择一个和该爱好相关的圈子</span></span><br><span class="line"><span class="keyword">const</span> groupsLike = groups.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.name.indexOf(hobit) !== <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">const</span> group = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * groupsLike.length)</span><br><span class="line"><span class="comment">// 与圈子里的人交流</span></span><br><span class="line"><span class="keyword">const</span> people = group.people</span><br><span class="line"><span class="keyword">const</span> index = <span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span>(++index &lt; people.length) &#123;</span><br><span class="line">    <span class="comment">// 选中一个人</span></span><br><span class="line">    <span class="keyword">let</span> man = people[index]</span><br><span class="line">    <span class="comment">// 进行勾搭，留下印象</span></span><br><span class="line">    <span class="keyword">let</span> feeling = man.chat()</span><br><span class="line">    <span class="comment">// 双方是否彼此欣赏喜欢</span></span><br><span class="line">    <span class="keyword">if</span> (isLike(feeling) &amp;&amp; man.isLike(feeling)) &#123;</span><br><span class="line">        <span class="comment">// 是的话，就成为朋友吧！</span></span><br><span class="line">        friends.push(man)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> friends</span><br></pre></td></tr></table></figure><p>由上伪代码可以发现，命令式编程会一步一步地告诉机器怎么去做一件事。好处就是可以清晰地知道程序具体执行每一件事的步骤和思路（<em>尽管上面伪代码我使用了一两个外部函数</em>）。而缺点就是使代码内部的状态变得难以追踪，不能清晰可见地知道状态的改变。</p><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><p>声明式编程关注于<strong>计算机执行的结果</strong>，即告诉机器应该做什么，但不告诉机器具体怎么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如如何从一个喜欢的圈子获得朋友</span></span><br><span class="line"><span class="comment">// 导入爱好</span></span><br><span class="line"><span class="keyword">import</span> &#123; hobits, isLike &#125; <span class="keyword">from</span> <span class="string">'mine'</span></span><br><span class="line"><span class="keyword">import</span> &#123; groups &#125; <span class="keyword">from</span> <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从喜欢的圈子里获得朋友</span></span><br><span class="line"><span class="keyword">const</span> friends = getFriends(groups, hobits, isLike)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> friends</span><br></pre></td></tr></table></figure><p>相对于命令式，声明式没有了冗长的实现步骤，取而代之的是一个封装好的 <code>getFriends</code> 函数，这样的好处是使得机器可以灵活地去处理得到结果，而非要一步一步按照命令无条件去执行程序。</p><p>总结来说，命令式编程需要你一步一步告诉机器怎么找朋友。而声明</p><p>通过一个更典型的例子来说明声明式与命令式的区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给数组的每一项字符串末尾加个 ！</span></span><br><span class="line"><span class="keyword">const</span> words = [<span class="string">'Micky'</span>, <span class="string">'Robot'</span>, <span class="string">'Kicy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令式编程</span></span><br><span class="line"><span class="keyword">const</span> words1 = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">    words.push(<span class="string">`<span class="subst">$&#123;words[i]&#125;</span>!`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式编程</span></span><br><span class="line"><span class="keyword">const</span> words2 = words.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="string">`<span class="subst">$&#123;item&#125;</span>!`</span>)</span><br></pre></td></tr></table></figure><h4 id="函数式编程-1"><a href="#函数式编程-1" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>函数式编程包含声明式编程的思想，即只关心做什么而不是怎么做。但函数式编程相较于声明式又多了一些特征。</p><h2 id="函数式编程的特征"><a href="#函数式编程的特征" class="headerlink" title="函数式编程的特征"></a>函数式编程的特征</h2><ul><li>一等公民</li><li>计算过程函数化</li><li>相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用</li><li>可缓存性、可移植性、自文档化等</li></ul><h4 id="一等公民"><a href="#一等公民" class="headerlink" title="一等公民"></a>一等公民</h4><p>即函数可以像对象数组一样当作值或参数传递，复制到变量等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hi = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hi "</span> + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greeting = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hi(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码 <code>greeting</code> 多包裹一层函数是多余的。因为 JavaScript 的函数式可调用的，当 <code>hi</code> 后面紧跟 <code>()</code> 时就会运行函数并返回一个值。如果没有括号，就简单地返回存储到这个变量里面的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br><span class="line"><span class="comment">// function(name) &#123;</span></span><br><span class="line"><span class="comment">//   return "Hi " + name</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">hi(<span class="string">'yyxx2z'</span>)</span><br><span class="line"><span class="comment">// "Hi yyxx2z"</span></span><br></pre></td></tr></table></figure><p>所以完全可以将 <code>hi</code> 函数如同对象数组赋值般，传递给 <code>greeting</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> greeting = hi</span><br><span class="line"></span><br><span class="line">greeting(<span class="string">'yyxx2z'</span>)</span><br><span class="line"><span class="comment">// "Hi yyxx2z"</span></span><br></pre></td></tr></table></figure><h4 id="追求纯函数"><a href="#追求纯函数" class="headerlink" title="追求纯函数"></a>追求纯函数</h4><p>纯函数的定义是：</p><blockquote><p>相同的输入，永远会得到相同的输出，没有任何可以观察的副作用。</p></blockquote><p>比较典型的是从某一数组截取元素， <code>splice</code> 与 <code>slice</code> ，前者会改变原数组，后者返回一个截取后的新数组，这就是可观察到副作用。</p><blockquote><p><em>副作用</em>是在计算结果的过程中，系统状态的一种变化，或者与外部世界进行的<em>可观察的交互</em>。</p></blockquote><p>再者，一个纯函数处理的所有数据均从传入的参数获取，凡是使用外部变量的，都是不纯的函数。因为此时函数的返回值会受外部环境影响，导致无法完全保证输入同输出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不纯</span></span><br><span class="line"><span class="keyword">let</span> action = <span class="string">'eat'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eatFruit</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;action&#125;</span> <span class="subst">$&#123;fruit&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eatFruit</span>(<span class="params">fruit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> action = <span class="string">'eat'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;action&#125;</span> <span class="subst">$&#123;fruit&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不纯的 <code>eatFruit</code> 函数会依赖一个对于函数不可控的外部变量 <code>action</code> ，导致了如果 <code>action</code> 被修改， <code>eatFruit</code>  函数就不能保证输入同输出。</p><p><strong>副作用包括有</strong>：</p><ul><li>可变数据</li><li>更改文件系统</li><li>DOM 查询</li><li>获取用户输入</li><li>发送一个 http 请求</li><li>……</li></ul><p>概括来说，只要是跟函数外部环境发生交互的都是副作用。</p><p>全部避免当然是不可行的，我们要做的就是让他们在可控范围内发生。函数式编程对于处理副作用有一种叫做容器(functor)的概念，我们这里暂且不提。</p><h4 id="可缓存性"><a href="#可缓存性" class="headerlink" title="可缓存性"></a>可缓存性</h4><p>使用纯函数有很多美妙的理由（尽管 <em>同输入同输出没有可观察的副作用</em> 就已经很美妙了），诸如因为不依赖外部变量，可移植性强；自文档化：函数本身传入参数和返回数据就可以作为了解函数的文档，因为这就是函数的全部了~；还有纯函数的可测试性合理性等等。</p><p>这里介绍一下纯函数的可缓存性。</p><p>纯函数能够根据输入来做缓存。实现缓存的是一种典型的 memoize 技术。</p><p>这里对 memoize 进行一个简单的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memoize = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将该返回的 function 所传入的参数格式化为 JSON 字符串</span></span><br><span class="line">        <span class="keyword">var</span> arg_str = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 判断该参数是否在 cache 中有缓存，有则使用缓存，没有则重新调用传入函数</span></span><br><span class="line">        cache[arg_str] = cache[arg_str] || f.apply(f, <span class="built_in">arguments</span>)</span><br><span class="line">        <span class="comment">// 返回缓存</span></span><br><span class="line">        <span class="keyword">return</span> cache[arg_str]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> squareNumber = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x*x &#125;)</span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// arguments: [4]</span></span><br><span class="line"><span class="comment">// arg_str: '&#123;"0":4&#125;'</span></span><br><span class="line"><span class="comment">// cache: &#123;&#123;"0":4&#125;: 16&#125;</span></span><br><span class="line"><span class="comment">// =&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">4</span>) <span class="comment">// 从缓存中读取输入值为 4 的结果</span></span><br><span class="line"><span class="comment">// =&gt; 16</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// arguments: [5]</span></span><br><span class="line"><span class="comment">// arg_str: '&#123;"0":5&#125;'</span></span><br><span class="line"><span class="comment">// cache: &#123;&#123;"0":4&#125;: 16, &#123;"0":5&#125;: 25&#125;</span></span><br><span class="line"><span class="comment">// =&gt; 25</span></span><br><span class="line"></span><br><span class="line">squareNumber(<span class="number">5</span>) <span class="comment">// 从缓存中读取输入值为 5 的结果</span></span><br><span class="line"><span class="comment">// =&gt; 25</span></span><br></pre></td></tr></table></figure><p>memoize 函数可以将计算过的传入参数和结果进行存储，再次传入相同参数时直接从缓存中读取参数返回结果，不会再进行一次函数的执行计算。</p><p>我们还可以通过将一个不纯的函数通过延迟执行的方式转换为纯函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pureHttpCall = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">url, params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> $.getJSON(url, params) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里为了将 http 请求相同参数返回的数据进行缓存，且需要再调用的时候再发起请求，就用延迟执行的方式包裹起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了观察方便，我们将 $.getJSON 改变为：</span></span><br><span class="line"><span class="keyword">var</span> pureHttpCall = memoize(<span class="function"><span class="keyword">function</span>(<span class="params">url, params</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'url:'</span> + url + <span class="string">', params: '</span> + <span class="built_in">JSON</span>.stringify(params) &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetchList = pureHttpCall(<span class="string">'/list'</span>, &#123; <span class="attr">limit</span>: <span class="number">20</span>, <span class="attr">page</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="comment">// memoize 中的 log</span></span><br><span class="line"><span class="comment">// arg_str: "&#123;"0":"/list","1":&#123;"limit":20,"page":1&#125;&#125;"</span></span><br><span class="line"><span class="comment">// cache: &#123;&#123;"0":"/list","1":&#123;"limit":20,"page":1&#125;&#125;: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">fetchList()</span><br><span class="line"><span class="comment">// "url: /list, params: &#123;"limit":20,"page":1&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fetchName = pureHttpCall(<span class="string">'/name'</span>, &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="comment">// arg_str: "&#123;"0":"/name","1":&#123;"id":1&#125;&#125;"</span></span><br><span class="line"><span class="comment">// cache: &#123;&#123;"0":"/list","1":&#123;"limit":20,"page":1&#125;&#125;: ƒ, &#123;"0":"/name","1":&#123;"id":1&#125;&#125;: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">fetchName()</span><br><span class="line"><span class="comment">// "url: /name, params:&#123;"id":1&#125;"</span></span><br></pre></td></tr></table></figure><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化的概念很简单，先传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>相当于对函数增加一部分预设，后面调用预设去处理接下来的数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;编程范式&lt;/li&gt;
&lt;li&gt;函数式编程的特征&lt;/li&gt;
&lt;li&gt;函数式编程解决的问题&lt;/li&gt;
&lt;li&gt;柯里化&lt;/li&gt;
&lt;li&gt;组合&lt;/li&gt;
&lt;li&gt;尾调用及尾调用优化&lt;/li&gt;
&lt;li&gt;Hindley-Minler 类型签名&lt;/li&gt;
&lt;li&gt;范畴论与函数式编程&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yyxx2z.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yyxx2z.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Abstract component in React/Vue</title>
    <link href="http://yyxx2z.github.io/2018/12/07/Abstract-component-in-React-Vue/"/>
    <id>http://yyxx2z.github.io/2018/12/07/Abstract-component-in-React-Vue/</id>
    <published>2018-12-07T07:11:35.000Z</published>
    <updated>2019-03-25T09:40:09.193Z</updated>
    
    <content type="html"><![CDATA[<p>从 SPA 时代开始前端不再只是 view 的承载，开始有了自己的业务逻辑。伴随着重复代码量的增加对 UI 和逻辑处理封装成独立的组件已经成为一个必然的趋势：低耦合高内聚，提高代码重用率，可单独测试，以及对多人团队协作效率的大大提高。React/Vue/Angular 的出现使我们不用了解如何去对 HTML CSS JS 分别单独进行组件化就能实现可复用组件。</p><p>而在开发时，我们容易对组件的抽象和设计有一个暧昧的判断。分割不清抽象组件时机，组件耦合性高，组件分割混乱无规范性。</p><a id="more"></a><h1 id="抽象组件原则"><a href="#抽象组件原则" class="headerlink" title="抽象组件原则"></a>抽象组件原则</h1><p><strong><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">单一功能原则</a></strong></p><p>抽象组件类似于函数式编程，没有外部依赖，在同一数据流下进行相同的行为反馈相同的表现。</p><p>独立性：组件应该是引入即用的，以微信小程序中写授权弹窗为例，在应用加载后不应该依赖于当前加载页面是否执行了授权状态查询而进行展示，而是应该将授权查询封装进组件，使组件的功能保持完整性和独立性。</p><p>而在 Vue 和 React 中，由于数据流和设计的不同，我们将分开介绍何时适合抽象组件。</p><h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h4 id="组件抽象流程"><a href="#组件抽象流程" class="headerlink" title="组件抽象流程"></a>组件抽象流程</h4><p>根据<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React理念</a>介绍，在 React 中抽象组件可大致分为以下步骤：</p><ol><li>对 UI 进行层级划分</li><li>创建静态版本</li><li>定义组件的最小完整表示</li><li>提升 state</li><li>添加反向数据流</li></ol><h4 id="根据数据构成进行组件划分"><a href="#根据数据构成进行组件划分" class="headerlink" title="根据数据构成进行组件划分"></a>根据数据构成进行组件划分</h4><p>在对页面 UI 进行层级划分后，我们可以对一些数据构成相同但是 UI 表现略有不同的组件归类为一个组件。如图两个 article-card ，虽然 UI 表现不一致，但是大都是由 banner + title + describe 等元素构成，部分不同可以通过 props 传入组件表现类型去控制部分元素的显隐和使用不同表现形式的 className 。</p><img src="/2018/12/07/Abstract-component-in-React-Vue/ui-example.png" title="This is an example image"><p>这样不仅能提高小组件的复用率和功能性，还能减少很多表现和功能类似的组件。</p><h4 id="容器组件和展示组件"><a href="#容器组件和展示组件" class="headerlink" title="容器组件和展示组件"></a>容器组件和展示组件</h4><p>即使你没有使用 Redux 进行你的 React 项目开发， 也可以参考 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="noopener">Presentational and Container Components</a> 的组件划分思想。<br>文中指出将 React 开发时的组件分为两种：</p><ul><li>容器组件：进行组件状态和数据的更新，以及下发 props，用于描述组件的运行逻辑。</li><li>展示组件：组件 UI 的展示，包含组件的样式和元素构成，通过接收 props 进行渲染，通过触发 props 的回调函数进行数据修改。</li></ul><p>这种做法可以让你在开发应用时对组件功能有更清晰的划分，对数据和事件管理有清晰的层级，使你更好地理解应用。同时也能增强代码的可读性和维护性，别人在 review 代码时能够看到一个清晰的数据流和事件流，使你的应用构成更加优雅 (/// v ///)</p><p>And 很大提高了组件的复用性，当一个组件变成纯粹的待数据填充的<strong>展示骨架</strong>， 那么他就可以适用于不同数据源的父组件和处理不同事件表现，因为此时展示组件没有自身的数据和修改数据的事件处理函数，一切都交给包含它的父容器组件去处理。</p><h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h4 id="组件抽象流程-1"><a href="#组件抽象流程-1" class="headerlink" title="组件抽象流程"></a>组件抽象流程</h4><ol><li>对 UI 进行功能块划分<br>对 UI 进行功能块的划分，如侧边栏和导航栏。</li><li><p>分化时确保该组件的复用率，提高可维护性<br>不需要每有稍微重复的地方就去分化组件(虽然这样很爽看上去使代码’感觉’很简洁优雅)<br>假如我们要写两个用户列表渲染，一个 admin 用户不带 delete 按钮， 一个普通用户带 delete 按钮</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;list-wrapper&quot;&gt;</span><br><span class="line">  &lt;ul class=&quot;list admin-list&quot;&gt;</span><br><span class="line">    &lt;li </span><br><span class="line">      class=&quot;list-item&quot; </span><br><span class="line">      v-for=&quot;item in adminList&quot; </span><br><span class="line">      :key=&quot;&quot; </span><br><span class="line">    &gt;</span><br><span class="line">      &lt;span class=&quot;item-id&quot;&gt;&#123;&#123;item.id&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;item.username&#125;&#125;&lt;span&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line"></span><br><span class="line">  &lt;ul class=&quot;list user-list&quot;&gt;</span><br><span class="line">    &lt;li </span><br><span class="line">      class=&quot;list-item&quot; </span><br><span class="line">      v-for=&quot;item in userList&quot; </span><br><span class="line">      :key=&quot;&quot; </span><br><span class="line">    &gt;</span><br><span class="line">      &lt;span class=&quot;item-id&quot;&gt;&#123;&#123;item.id&#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;item.username&#125;&#125;&lt;span&gt;</span><br><span class="line">      &lt;button class=&quot;interaction-button&quot; @click=&quot;delete(item.id)&quot; &gt;删除&lt;/button&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>如果对其进行抽象组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;list-wrapper&quot;&gt;</span><br><span class="line">  &lt;UsersList </span><br><span class="line">    :list=&quot;adminList&quot;</span><br><span class="line">    :type=&quot;admin&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;UsersList </span><br><span class="line">    :list=&quot;userList&quot;</span><br><span class="line">    @deleteItem=&quot;delete&quot; </span><br><span class="line">    :type=&quot;normal&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这样是不是很优雅简洁呀！可是当你的 vue 页面都是这样一大堆组件去构成时，或者是像上面 React 介绍的容器组件和展示组件去写 vue 组件时，虽然你的页面构成简洁清晰了，但是当别人需要维护<strong>只在一个页面或者一个块少量使用的组件</strong>时，就会导致他得多次打开和寻找你的组件依赖文件，虽然你在写的时候爽了，却极大增加了维护的工作量。<br>所以在 Vue 中，抽象一个组件的时机应该是当该代码片段在当前页有多次复用或在多个页面有复用的情况时，再进行组件抽取。</p></li><li><p>对组件进行独立完整地封装<br>当你在对组件进行封装的时候，尽量保证组件的完整性和独立性，最好的效果是组件引入即用。而非对外部有一定的依赖。</p></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>React 和 Vue 中划分组件有所不同。<br>React 是以拆分最小单元为目的进行组件划分，提升 state 使得组件数据通过 props 单向传递更加优雅。<br>Vue 是以功能划分为主，在保证可维护性的情况下分化出复用率高的组件。组件以业务目的为主要划分。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从 SPA 时代开始前端不再只是 view 的承载，开始有了自己的业务逻辑。伴随着重复代码量的增加对 UI 和逻辑处理封装成独立的组件已经成为一个必然的趋势：低耦合高内聚，提高代码重用率，可单独测试，以及对多人团队协作效率的大大提高。React/Vue/Angular 的出现使我们不用了解如何去对 HTML CSS JS 分别单独进行组件化就能实现可复用组件。&lt;/p&gt;
&lt;p&gt;而在开发时，我们容易对组件的抽象和设计有一个暧昧的判断。分割不清抽象组件时机，组件耦合性高，组件分割混乱无规范性。&lt;/p&gt;
    
    </summary>
    
      <category term="React/Vue" scheme="http://yyxx2z.github.io/categories/React-Vue/"/>
    
    
      <category term="JavaScript" scheme="http://yyxx2z.github.io/tags/JavaScript/"/>
    
      <category term="Vue" scheme="http://yyxx2z.github.io/tags/Vue/"/>
    
      <category term="React" scheme="http://yyxx2z.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>跨域概述</title>
    <link href="http://yyxx2z.github.io/2018/10/15/%E8%B7%A8%E5%9F%9F%E6%A6%82%E8%BF%B0/"/>
    <id>http://yyxx2z.github.io/2018/10/15/跨域概述/</id>
    <published>2018-10-15T09:35:21.000Z</published>
    <updated>2019-03-25T10:04:38.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨什么域"><a href="#跨什么域" class="headerlink" title="跨什么域"></a>跨什么域</h2><p><span style="color:red;">Origin null is not allowed by Access-Control-Allow-Origin</span></p><p>当我们遇到以上报错时，恭喜你，遇到跨域问题了。</p><blockquote><p>A <strong>cross-domain solution</strong> (<strong>CDS</strong>) is a means of <a href="https://en.wikipedia.org/wiki/Information_assurance" target="_blank" rel="noopener">information assurance</a> that provides the ability to manually or automatically access or transfer information between two or more differing security domains.</p><p><a href="https://en.wikipedia.org/wiki/Cross-domain_solution" target="_blank" rel="noopener">维基百科</a></p></blockquote><p>跨域是跨的安全域，指可以在两个或多个不同的安全域之间手动或自动访问或传输信息。</p><p>而安全域指的是符合同源策略（same-origin policy）的域。<br><a id="more"></a></p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><blockquote><p><strong>同源策略</strong>限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p><p>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的<strong>源</strong>。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">MDN</a></p></blockquote><p>同源的重点，在于三相同：</p><ul><li>域名（二级域名也属不同）</li><li>协议（https 和 http 为不同）</li><li>端口（8080 和 8081） </li></ul><p>如果不同源，则无法加载资源。如 A 网站保存的 cookie，B 网站无法打开一样。如 AJAX 请求就只能发给同源的网址，否则就会报错。</p><h4 id="可以跨源引用的资源"><a href="#可以跨源引用的资源" class="headerlink" title="可以跨源引用的资源"></a>可以跨源引用的资源</h4><ul><li>script 标签</li><li>link 标签</li><li>img 标签</li><li>video 和 audio 标签</li><li>@font-face 引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts</li><li>frame 和 iframe 可以载入人和资源。站点可以使用<a href="https://developer.mozilla.org/zh-CN/docs/HTTP/X-Frame-Options" target="_blank" rel="noopener">X-Frame-Options</a>消息头来阻止这种形式的跨域交互。</li></ul><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>保证用户信息安全，放置被其他网站恶意使用。</p><h2 id="常见的请求跨域方式"><a href="#常见的请求跨域方式" class="headerlink" title="常见的请求跨域方式"></a>常见的请求跨域方式</h2><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON 是一种数据格式，而 JSONP 是一种数据调用方式。即可以通过添加一个 <code>script</code> 标签向服务器请求 JSON 数据，服务器收到请求后将数据放在一个指定名字的回调函数里传回来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态插入 script 元素，由它向跨域网址发出请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScript</span>(<span class="params">src</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    script.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>)</span><br><span class="line">    script.src = src</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback 字段是必须的</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>)</span><br><span class="line">  <span class="comment">// 浏览器请求结束后执行 foo 函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Your public IP address is: '</span> + data.ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点，该方式仅限于 get 请求。</p><h4 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h4><p>websocket 协议不实行同源策略。可以通过请求头中的 <code>origin</code> 字段表示请求的请求源。</p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>跨资源分享 (Cross-Origin Resource Sharing) 是 H5 规范定义中对 AJAX 请求的根本解决方法，CORS 允许发任意请求。CORS 是一种机制，现代浏览器支持在 API 容器中（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener">Fetch</a> ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。</p><p><strong>需要用到 CORS 的情况有</strong>：</p><ul><li>XMLHttpRequest 或 fetch</li><li>web 字体 (CSS 中通过<code>@font-face</code>使用跨域字体资源)</li><li>WebGL 贴图</li><li>使用 <code>drawImage</code> 将 Image/video 画面绘制到 canvas</li><li>样式表</li></ul><h4 id="CORS-通信的实现"><a href="#CORS-通信的实现" class="headerlink" title="CORS 通信的实现"></a>CORS 通信的实现</h4><p>对于前端来说，CORS 是在浏览器发现 AJAX 请求跨域时自动执行的。当跨域请求发起被浏览器识别，浏览器会自动添加一些请求头，有时候还会多一次附加的请求。</p><p>所以 CORS 的通信主要是在服务器端实现 CORS 接口。</p><p>浏览器会将 CORS 请求分为两类：简单请求和非简单请求。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>同时满足以下两个条件的，为简单请求：</p><ul><li>请求方法是以下三种之一的<ul><li>HEAD</li><li>POST</li><li>GET</li></ul></li><li>HTTP 请求头信息不超出一下几种字段<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type: 只限于三个值<ul><li>application/x-www-form-unlencoded</li><li>multipart/form-date</li><li>text-plain</li></ul></li></ul></li></ul><p>对于简单请求，浏览器会在头信息中加入一个说明本次请求的来源（协议 + 域名 + 端口）的 <code>Origin</code> 字段。服务器会根据这个值来决定是否同意该请求。</p><p>如果 <code>Origin</code> 指定源不在许可范围之内，服务器会返回一个正常的 HTTP 回应（可能是 200），该回应中不包含说明服务器许可制定源的 <code>Access-Control-Allow-Origin</code> 字段，并抛出一个可被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调函数捕获的错误。</p><p>如果 <code>Origin</code> 在许可源范围内，请求头中会包含以下字段：</p><ol><li><p>Access-Control-Allow-Origin</p><p>必须字段，请求成功 <code>Origin</code> 字段的值或 <em>， </em> 表示接受所有 <code>Origin</code>。</p></li><li><p>Access-Control-Allow-Credentials</p><p>可选字段，表示是否允许发送 Cookie ， 值为布尔值，默认情况下 Cookie 不包含在 CORS 请求中。</p><p>除此之外，前端还得将 Ajax 请求中的 <code>withCredentials</code> 属性打开</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果需要发送 Cookie ， <code>Access-Control-Allow-Origin</code> 就不能设置为 *</p></li><li><p>Access-Control-Expose-Headers</p><p>可选字段。CORS 请求时， XMLHttpRequest 对象的 <code>getResponseHeader()</code> 方法只能拿到留个基本字段：<code>Cache-Control</code> 、<code>Content-Language</code> 、<code>Content-Type</code> 、<code>Expires</code> 、<code>Last-MOdified</code> 、<code>Pragma</code>。如果想要其他字段，就必须在 <code>Access-Control-Expose-Headers</code> 中指定。</p></li></ol><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>不满足简单请求的，统一归为非简单请求。</p><p>比如请求方式是 <code>PUT</code> 或者 <code>DELETE</code> ， 或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code> 。</p><p>非简单请求会在正式通信前，增加一次 HTTP 预检查询请求</p><img src="/2018/10/15/跨域概述/CORS-UNSIMPLE-1.png" title="CORS-UNSIMPLE-IMAGE1"><p>该请求头为：</p><img src="/2018/10/15/跨域概述/CORS-UNSIMPLE-2.png" title="CORS-UNSIMPLE-IMAGE2"><p>预检请求用的请求方法是 <code>OPTIONS</code> , 表示这个请求是用来询问服务器的。</p><p>除此之外，我们还可以看到不同于简单请求的两个字段：</p><ol><li><p>Access-Control-Allow-Method 和 Access-Control-Request-Method</p><p>必须字段。Allow 是服务器允许的请求方式， Request 是该请求用到的请求方式。</p></li><li><p>Access-Control-Allow-Header 和  Access-Control-Request-Headers</p><p>指定浏览器 CORS 请求头会额外发送的头信息字段。Allow 是服务器允许的额外请求头字段， Request 是该请求用到的字段。</p></li></ol><p>预检请求之后，就会再次发起一次正常请求请求数据。</p><p>其中 <code>Access-Control-Allow-Origin</code> 字段是每次回应都会包含的。</p><h2 id="canvas-中-drawImage-中的跨域问题"><a href="#canvas-中-drawImage-中的跨域问题" class="headerlink" title="canvas 中 drawImage() 中的跨域问题"></a>canvas 中 drawImage() 中的跨域问题</h2><p>当我们在 canvas 画布中用 <code>drawImage()</code> 使用跨域的图片时，图片会被渲染，但此时的 canvas 是被污染的状态，即不能读取 drawImage 中图片的数据。也就是不能使用 <code>toBolb()</code>，<code>toDataURL()</code>,  <code>getImageData()</code> 方法，调用会抛出安全错误。</p><p>解决该问题只需要两个步骤：</p><ol><li>给图片 <code>crossorigin</code> 属性设置 <code>Anonymous</code></li><li>图片服务端允许 CORS 跨域</li></ol><p>步骤 2 上文已经介绍，下面我们来说下步骤一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image()</span><br><span class="line">image.crossorigin = <span class="string">'Anonymous'</span></span><br><span class="line">image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br><span class="line">image.src = <span class="string">''</span></span><br></pre></td></tr></table></figure><p><code>crossorigin</code> 属性表明是否使用 CORS 完成相关图像的抓取。允许的值有：</p><ul><li><p>use-credentials </p><p>一个有证书的跨域请求被发送（比如，a cookie, a certificate, and HTTP Basic authentication is performed））。如果服务器没有给源站发送证书（通过 Access-Control-Allow-Credentials: HTTP header），图像会被污染。</p></li><li><p>anonymous</p><p>执行一个跨域请求但是没有发送证书（比如，没有 cookie，没有 X.509 证书，没有 HTTP 基本的授权认证））。如果服务器没有给源站发送证书（通过 Access-Control-Allow-Credentials: HTTP header），图像会被污染。</p></li></ul><p>当用户没有设置该值的时候，默认不使用 CORS 发起请求。如果无效，默认当做 anonymous 关键字生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">image.crossorigin = <span class="string">''</span> <span class="comment">// 无效，当做 anonymous 关键字生效</span></span><br><span class="line">image.crossorigin = <span class="string">'aaa'</span> <span class="comment">// 无效，当做 anonymous 关键字生效</span></span><br></pre></td></tr></table></figure><p>参考文章：</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跨什么域&quot;&gt;&lt;a href=&quot;#跨什么域&quot; class=&quot;headerlink&quot; title=&quot;跨什么域&quot;&gt;&lt;/a&gt;跨什么域&lt;/h2&gt;&lt;p&gt;&lt;span style=&quot;color:red;&quot;&gt;Origin null is not allowed by Access-Control-Allow-Origin&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们遇到以上报错时，恭喜你，遇到跨域问题了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;cross-domain solution&lt;/strong&gt; (&lt;strong&gt;CDS&lt;/strong&gt;) is a means of &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_assurance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;information assurance&lt;/a&gt; that provides the ability to manually or automatically access or transfer information between two or more differing security domains.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-domain_solution&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跨域是跨的安全域，指可以在两个或多个不同的安全域之间手动或自动访问或传输信息。&lt;/p&gt;
&lt;p&gt;而安全域指的是符合同源策略（same-origin policy）的域。&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yyxx2z.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yyxx2z.github.io/tags/JavaScript/"/>
    
      <category term="浏览器" scheme="http://yyxx2z.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
